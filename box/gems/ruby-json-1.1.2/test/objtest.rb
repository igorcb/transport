#
# Unit Tests for JSON Objects
#  Copyright (C) 2002 Rafael R. Sevilla <dido@imperium.ph>
#  This file is part of JSON for Ruby
#
#  JSON for Ruby is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public License
#  as published by the Free Software Foundation; either version 2.1 of
#  the License, or (at your option) any later version.
#
#  JSON for Ruby is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details. 
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with JSON for Ruby; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
#  02111-1307 USA.
#
# Author:: Rafael R. Sevilla (mailto:dido@imperium.ph)
# Copyright:: Copyright (c) 2003 Rafael R. Sevilla
# License:: GNU Lesser General Public License
# $Id: objtest.rb,v 1.3 2006/02/08 20:02:22 tmyrtle Exp $
#

require 'test/unit'
require 'json/lexer'
require 'json/objects'

class ObjectTest < Test::Unit::TestCase
  def test_to_json
    obj = Hash.new
    obj['foo'] = 'bar'
    obj['xyz'] = 1
    obj['euler'] = 0.577215665

    str = obj.to_json
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj.class == Hash, "Hash was not generated by deserialization")
    assert(sobj['foo'] == 'bar', "error in serialization of a string to JSON")
    assert(sobj['xyz'] == 1, "error in serialization of a FixNum to JSON")
    assert(sobj['euler'] == 0.577215665, "error in serialization of a float to JSON")
  end


  def test_to_json_string
    obj = { "key"=>"value" }
    str = obj.to_json
    assert(str == '{"key":"value"}', "basic serialization")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization")

    obj = { "key"=>'"' }
    str = obj.to_json
    assert(str == '{"key":"\""}', "basic serialization-quote")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-quote")

    obj = { "key"=>'/' }
    str = obj.to_json
    assert(str == '{"key":"\/"}', "basic serialization-solidus")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-solidus")

    obj = { "key"=>'\\' }
    str = obj.to_json
    assert(str == '{"key":"\\\\"}', "basic serialization-reverse solidus")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-reverse solidus")

    obj = { "key"=>"\b" }
    str = obj.to_json
    assert(str == '{"key":"\b"}', "basic serialization-backspace")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic serialization-backspace")

    obj = { "key"=>"\f" }
    str = obj.to_json
    assert(str == '{"key":"\f"}', "basic serialization-formfeed")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-formfeed")

    obj = { "key"=>"\n" }
    str = obj.to_json
    assert(str == '{"key":"\n"}', "basic serialization-newline")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-newline")

    obj = { "key"=>"\r" }
    str = obj.to_json
    assert(str == '{"key":"\r"}', "basic serialization-carriage return")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-carriage return")

    obj = { "key"=>"\t" }
    str = obj.to_json
    assert(str == '{"key":"\t"}', "basic serialization-horizontal tab")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-horizontal tab")
  end


  def test_to_json_number
    obj = { "key"=>125 }
    str = obj.to_json
    assert(str == '{"key":125}', "basic serialization-integer")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-integer")

    obj = { "key"=>-125 }
    str = obj.to_json
    assert(str == '{"key":-125}', "basic serialization-negative integer")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-negative integer")

    obj = { "key"=>125.27 }
    str = obj.to_json
    assert(str == '{"key":125.27}', "basic serialization-float")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-float")

    obj = { "key"=>-125.27 }
    str = obj.to_json
    assert(str == '{"key":-125.27}', "basic serialization-negative float")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-negative float")
  end


  def test_to_json_bool
    obj = { "key"=>true }
    str = obj.to_json
    assert(str == '{"key":true}', "basic serialization-true")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-true")

    obj = { "key"=>false }
    str = obj.to_json
    assert(str == '{"key":false}', "basic serialization-false")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-false")
  end


  def test_to_json_null
    obj = { "key"=>nil }
    str = obj.to_json
    assert(str == '{"key":null}', "basic serialization-null")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-null")
  end


  def test_to_json_empty
    obj = { "key"=>[] }
    str = obj.to_json
    assert(str == '{"key":[]}', "basic serialization-empty array")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"].class==Array, "basic deserialization-empty array1")
    assert(sobj["key"].length==0, "basic deserialization-empty array2")

    obj = { "key"=>{} }
    str = obj.to_json
    assert(str == '{"key":{}}', "basic serialization-empty hash")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"].class==Hash, "basic deserialization-empty hash1")
    assert(sobj["key"].length==0, "basic deserialization-empty hash2")

    obj = { "key"=>"" }
    str = obj.to_json
    assert(str == '{"key":""}', "basic serialization-empty string")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-empty string")
  end


  def test_to_json_subobject
    obj = { "key"=>{ "key"=>"value" } }
    str = obj.to_json
    assert(str == '{"key":{"key":"value"}}', "basic serialization-subobject hash")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-subobject hash")

    obj = { "key"=>[1,2,3] }
    str = obj.to_json
    assert(str == '{"key":[1,2,3]}', "basic serialization-subobject array")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-subobject array")

    obj = { "key"=>[1,2,[4,5]] }
    str = obj.to_json
    assert(str == '{"key":[1,2,[4,5]]}', "basic serialization-subobject array")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-subobject array")

    obj = { "key"=>[1,2,{"key"=>"value"}] }
    str = obj.to_json
    assert(str == '{"key":[1,2,{"key":"value"}]}', "basic serialization-subobject array/hash")
    sobj = JSON::Lexer.new(str).nextvalue
    assert(sobj["key"] == obj["key"], "basic deserialization-subobject array/hash")


  end

end
